'''
This script automatically finds JSON result files in the results directory
(generated by running uav.py) and creates separate KPI comparison plots.

Usage:
    python compare_algorithms.py
'''

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
import glob

def load_results_from_directory(results_dir="results"):
    '''
    Load all JSON result files from the results directory.
    Returns a dictionary mapping algorithm names to DataFrames.
    '''
    # Get the directory where this script is located
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # Resolve results directory relative to script location
    results_path = os.path.join(script_dir, results_dir)
    
    # Check if results directory exists relative to script
    if not os.path.exists(results_path):
        # Try current working directory as fallback
        cwd_results = os.path.join(os.getcwd(), results_dir)
        if os.path.exists(cwd_results):
            results_path = cwd_results
        else:
            raise FileNotFoundError(
                f"Results directory not found.\n"
                f"  Checked: {results_path}\n"
                f"  Also checked: {cwd_results}\n"
                f"  Current working directory: {os.getcwd()}\n"
                f"  Script location: {script_dir}\n"
                f"Please ensure 'results' directory exists with JSON result files."
            )
    
    print(f"Looking for result files in: {results_path}")
    
    # Find all JSON files in results directory
    json_files = glob.glob(os.path.join(results_path, "*_results.json"))
    
    if not json_files:
        # List what files are actually in the directory for debugging
        existing_files = os.listdir(results_path) if os.path.exists(results_path) else []
        raise FileNotFoundError(
            f"No result files (*_results.json) found in '{results_path}' directory.\n"
            f"  Existing files: {existing_files}\n"
            f"Please run uav.py for each algorithm first to generate result files."
        )
    
    dataframes = {}
    algorithm_names = []
    
    for json_file in json_files:
        try:
            with open(json_file, 'r') as f:
                data = json.load(f)
            
            algorithm_name = data.get('algorithm', 'Unknown')
            
            # Create DataFrame from the data
            df = pd.DataFrame({
                'episode': data.get('episodes', []),
                'reward': data.get('rewards', []),
                'flight_time': data.get('flight_times', []),
                'terminated': data.get('terminated', [])
            })
            
            # Extract best_trajectory data
            best_traj = data.get('best_trajectory', {})
            if best_traj:
                traj = best_traj.get('trajectory', [])
                if traj:
                    print(f"  Found best trajectory: Episode {best_traj.get('episode', 'N/A')}, "
                          f"Reward: {best_traj.get('reward', 0):.2f}, "
                          f"Length: {len(traj)} positions")
                    if len(traj) > 0:
                        print(f"    First position: {traj[0]}, Last position: {traj[-1]}")
                else:
                    print(f"  Warning: best_trajectory exists but trajectory list is empty")
            else:
                print(f"  Warning: No best_trajectory data found in JSON")
            
            # Add summary statistics as attributes
            df.attrs = {
                'algorithm': algorithm_name,
                'num_episodes': data.get('num_episodes', len(df)),
                'avg_reward': data.get('avg_reward', df['reward'].mean()),
                'std_reward': data.get('std_reward', df['reward'].std()),
                'min_reward': data.get('min_reward', df['reward'].min()),
                'max_reward': data.get('max_reward', df['reward'].max()),
                'success_rate': data.get('success_rate', df['terminated'].sum() / len(df) * 100),
                'avg_flight_time': data.get('avg_flight_time', df['flight_time'].mean()),
                'best_trajectory': best_traj
            }
            
            dataframes[algorithm_name] = df
            algorithm_names.append(algorithm_name)
            
            print(f"Loaded {algorithm_name}: {len(df)} episodes")
            
        except Exception as e:
            print(f"Warning: Could not load {json_file}: {e}")
            continue
    
    # Check if we have the expected algorithms
    expected_algorithms = ['Random Action', 'SARSA', 'Q-Learning']
    missing = [alg for alg in expected_algorithms if alg not in dataframes]
    
    if missing:
        print(f"\nWarning: Missing algorithms: {', '.join(missing)}")
        print(f"Found algorithms: {', '.join(dataframes.keys())}")
    
    return dataframes

def create_kpi_plots(dataframes, output_dir="results/plots"):
    '''
    Create separate KPI plots from pandas DataFrames.
    Each KPI is saved as a separate PNG file.
    
    dataframes: Dictionary mapping algorithm names to DataFrames
    output_dir: Directory to save plots
    '''
    # Get the directory where this script is located
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # Resolve output directory relative to script location
    output_path = os.path.join(script_dir, output_dir)
    os.makedirs(output_path, exist_ok=True)
    
    # Algorithm colors
    colors = {
        'Random Action': 'red',
        'SARSA': 'blue',
        'Q-Learning': 'green'
    }
    
    # Prepare summary DataFrame for easier plotting
    summary_data = []
    for algo_name, df in dataframes.items():
        attrs = df.attrs
        summary_data.append({
            'algorithm': attrs['algorithm'],
            'avg_reward': attrs['avg_reward'],
            'std_reward': attrs['std_reward'],
            'min_reward': attrs['min_reward'],
            'max_reward': attrs['max_reward'],
            'success_rate': attrs['success_rate'],
            'avg_flight_time': attrs['avg_flight_time']
        })
    
    summary_df = pd.DataFrame(summary_data)
    
    # KPI 1: Reward After Episodes (Learning Curve)
    fig1, ax1 = plt.subplots(figsize=(12, 6))
    for algo_name, df in dataframes.items():
        # Calculate moving average for smoother plot
        window = max(1, len(df) // 100)
        if window > 1:
            df_smooth = df.copy()
            df_smooth['reward_ma'] = df_smooth['reward'].rolling(window=window, center=False).mean()
            df_smooth = df_smooth[window-1:]  # Remove NaN values
            ax1.plot(df_smooth['episode'], df_smooth['reward_ma'], 
                    label=algo_name, color=colors.get(algo_name, 'black'), 
                    alpha=0.7, linewidth=2)
        else:
            ax1.plot(df['episode'], df['reward'], 
                    label=algo_name, color=colors.get(algo_name, 'black'), 
                    alpha=0.7, linewidth=2)
    
    ax1.set_xlabel('Episode', fontsize=12)
    ax1.set_ylabel('Reward', fontsize=12)
    ax1.set_title('KPI 1: Reward After Episodes', fontsize=14, fontweight='bold')
    ax1.legend(fontsize=11)
    ax1.grid(True, alpha=0.3)
    plt.tight_layout()
    fig1.savefig(os.path.join(output_path, 'KPI1.png'), dpi=300, bbox_inches='tight')
    plt.close(fig1)
    print(f"Saved KPI1.png: Reward After Episodes")
    
    # KPI 2: Average Flying Time
    fig2, ax2 = plt.subplots(figsize=(10, 6))
    bars = ax2.bar(summary_df['algorithm'], summary_df['avg_flight_time'], 
                   color=[colors.get(name, 'gray') for name in summary_df['algorithm']], 
                   alpha=0.7)
    ax2.set_ylabel('Average Flight Time (steps)', fontsize=12)
    ax2.set_title('KPI 2: Average Flying Time', fontsize=14, fontweight='bold')
    ax2.axhline(y=50, color='r', linestyle='--', alpha=0.5, label='Target (50 steps)')
    ax2.grid(True, alpha=0.3, axis='y')
    ax2.tick_params(axis='x', rotation=45)
    ax2.legend(fontsize=10)
    
    # Add value labels on bars
    for bar, avg_time in zip(bars, summary_df['avg_flight_time']):
        height = bar.get_height()
        ax2.text(bar.get_x() + bar.get_width()/2., height,
                f'{avg_time:.1f}', ha='center', va='bottom', fontsize=11)
    
    plt.tight_layout()
    fig2.savefig(os.path.join(output_path, 'KPI2.png'), dpi=300, bbox_inches='tight')
    plt.close(fig2)
    print(f"Saved KPI2.png: Average Flying Time")
    
    # KPI 3: Average Reward
    fig3, ax3 = plt.subplots(figsize=(10, 6))
    bars = ax3.bar(summary_df['algorithm'], summary_df['avg_reward'], 
                   color=[colors.get(name, 'gray') for name in summary_df['algorithm']], 
                   alpha=0.7)
    ax3.set_ylabel('Average Reward', fontsize=12)
    ax3.set_title('KPI 3: Average Reward', fontsize=14, fontweight='bold')
    ax3.grid(True, alpha=0.3, axis='y')
    ax3.tick_params(axis='x', rotation=45)
    
    # Add value labels on bars
    for bar, avg in zip(bars, summary_df['avg_reward']):
        height = bar.get_height()
        ax3.text(bar.get_x() + bar.get_width()/2., height,
                f'{avg:.2f}', ha='center', va='bottom', fontsize=11)
    
    plt.tight_layout()
    fig3.savefig(os.path.join(output_path, 'KPI3.png'), dpi=300, bbox_inches='tight')
    plt.close(fig3)
    print(f"Saved KPI3.png: Average Reward")
    
    # KPI 4: Min Max Reward Range
    fig4, ax4 = plt.subplots(figsize=(10, 6))
    x_pos = np.arange(len(summary_df))
    width = 0.25
    
    bars_min = ax4.bar(x_pos - width, summary_df['min_reward'], width, 
            label='Min', alpha=0.7, color='lightcoral')
    bars_avg = ax4.bar(x_pos, summary_df['avg_reward'], width, 
            label='Average', alpha=0.7, color='steelblue')
    bars_max = ax4.bar(x_pos + width, summary_df['max_reward'], width, 
            label='Max', alpha=0.7, color='lightgreen')
    
    ax4.set_ylabel('Reward', fontsize=12)
    ax4.set_title('KPI 4: Min Max Reward Range', fontsize=14, fontweight='bold')
    ax4.set_xticks(x_pos)
    ax4.set_xticklabels(summary_df['algorithm'], rotation=45, ha='right')
    ax4.legend(fontsize=10)
    ax4.grid(True, alpha=0.3, axis='y')
    
    # Add value labels on bars
    for bars_group in [bars_min, bars_avg, bars_max]:
        for bar in bars_group:
            height = bar.get_height()
            ax4.text(bar.get_x() + bar.get_width()/2., height,
                    f'{height:.2f}', ha='center', va='bottom', fontsize=9)
    
    plt.tight_layout()
    fig4.savefig(os.path.join(output_path, 'KPI4.png'), dpi=300, bbox_inches='tight')
    plt.close(fig4)
    print(f"Saved KPI4.png: Min Max Reward Range")
    
    # KPI 5: Success Rate
    fig5, ax5 = plt.subplots(figsize=(10, 6))
    bars = ax5.bar(summary_df['algorithm'], summary_df['success_rate'], 
                   color=[colors.get(name, 'gray') for name in summary_df['algorithm']], 
                   alpha=0.7)
    ax5.set_ylabel('Success Rate (%)', fontsize=12)
    ax5.set_title('KPI 5: Success Rate', fontsize=14, fontweight='bold')
    ax5.set_ylim([0, 100])
    ax5.grid(True, alpha=0.3, axis='y')
    ax5.tick_params(axis='x', rotation=45)
    
    # Add value labels on bars
    for bar, rate in zip(bars, summary_df['success_rate']):
        height = bar.get_height()
        ax5.text(bar.get_x() + bar.get_width()/2., height,
                f'{rate:.1f}%', ha='center', va='bottom', fontsize=11)
    
    plt.tight_layout()
    fig5.savefig(os.path.join(output_path, 'KPI5.png'), dpi=300, bbox_inches='tight')
    plt.close(fig5)
    print(f"Saved KPI5.png: Success Rate")
    
    print(f"\nAll KPI plots saved to {output_path}/")

def create_trajectory_plot(dataframes, output_dir="results/plots"):
    '''
    Create a grid plot showing the best trajectory for each algorithm.
    The plot shows the 15x15 grid with obstacles, SNs, and trajectories.
    
    dataframes: Dictionary mapping algorithm names to DataFrames (with trajectory data in attrs)
    output_dir: Directory to save plots
    '''
    # Get the directory where this script is located
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # Resolve output directory relative to script location
    output_path = os.path.join(script_dir, output_dir)
    os.makedirs(output_path, exist_ok=True)
    
    # Grid parameters (from uav2dgrid.py)
    ROWS, COLS = 15, 15
    
    # Obstacle positions (from uav2dgrid.py: OBSTACLE.POS_LIST)
    obstacles = []
    for x in range(9, 11):
        for y in range(8, 12):
            obstacles.append((x, y))
    
    # SN positions (from uav2dgrid.py: SN.POS)
    # Note: SN positions are stored as (col, row) with fractional values
    sn_positions = [
        (4.5, 2.5), (11.5, 6.5), (10, 3), (2, 5),
        (7, 1), (13, 4), (5, 8), (12, 10)
    ]
    
    # Start/End position (left-bottom: col=0, row=14)
    start_pos = (0, 14)
    end_pos = (0, 14)
    
    # Algorithm colors and styles
    algo_styles = {
        'Random Action': {'color': 'red', 'linestyle': '-', 'linewidth': 2, 'alpha': 0.7, 'marker': 'o', 'markersize': 4},
        'SARSA': {'color': 'blue', 'linestyle': '-', 'linewidth': 2, 'alpha': 0.7, 'marker': 's', 'markersize': 4},
        'Q-Learning': {'color': 'green', 'linestyle': '-', 'linewidth': 2, 'alpha': 0.7, 'marker': '^', 'markersize': 4}
    }
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, 12))
    
    # Draw grid
    for i in range(ROWS + 1):
        ax.axhline(i - 0.5, color='black', linewidth=0.5, alpha=0.3)
    for j in range(COLS + 1):
        ax.axvline(j - 0.5, color='black', linewidth=0.5, alpha=0.3)
    
    # Draw obstacles (dark grey)
    for obs_col, obs_row in obstacles:
        rect = plt.Rectangle((obs_col - 0.5, obs_row - 0.5), 1, 1, 
                            facecolor='#464646', edgecolor='black', linewidth=0.5)
        ax.add_patch(rect)
    
    # Draw SNs (blue circles)
    for sn_col, sn_row in sn_positions:
        circle = plt.Circle((sn_col, sn_row), 0.3, color='blue', zorder=5)
        ax.add_patch(circle)
    
    # Draw start position (green square with X)
    start_rect = plt.Rectangle((start_pos[0] - 0.5, start_pos[1] - 0.5), 1, 1, 
                               facecolor='darkgreen', edgecolor='black', linewidth=1, alpha=0.7)
    ax.add_patch(start_rect)
    ax.text(start_pos[0], start_pos[1], 'X', ha='center', va='center', 
           color='white', fontsize=14, fontweight='bold', zorder=6)
    
    # Draw trajectories for each algorithm (only SARSA and Q-Learning)
    algorithms_to_plot = ['SARSA', 'Q-Learning']
    plotted_count = 0
    
    for algo_name, df in dataframes.items():
        # Skip Random Action - only plot SARSA and Q-Learning
        if algo_name not in algorithms_to_plot:
            print(f"Skipping {algo_name} trajectory (only plotting SARSA and Q-Learning)")
            continue
            
        best_traj_data = df.attrs.get('best_trajectory', {})
        trajectory = best_traj_data.get('trajectory', [])
        
        # Validate trajectory data
        if not trajectory:
            print(f"Warning: No trajectory data found for {algo_name}")
            continue
            
        if not isinstance(trajectory, list):
            print(f"Warning: Trajectory data for {algo_name} is not a list: {type(trajectory)}")
            continue
            
        if len(trajectory) == 0:
            print(f"Warning: Empty trajectory for {algo_name}")
            continue
        
        # Validate trajectory structure - should be list of [col, row] pairs
        try:
            # Extract x (col) and y (row) coordinates
            # Note: trajectory is stored as [col, row] pairs
            traj_cols = []
            traj_rows = []
            for pos in trajectory:
                if not isinstance(pos, (list, tuple)) or len(pos) < 2:
                    print(f"Warning: Invalid position format in {algo_name} trajectory: {pos}")
                    continue
                traj_cols.append(float(pos[0]))  # col
                traj_rows.append(float(pos[1]))   # row
            
            if len(traj_cols) == 0:
                print(f"Warning: No valid positions found in {algo_name} trajectory")
                continue
                
            print(f"Plotting {algo_name}: {len(traj_cols)} positions, Episode {best_traj_data.get('episode', 'N/A')}, Reward: {best_traj_data.get('reward', 0):.2f}")
            print(f"  First position: [{traj_cols[0]}, {traj_rows[0]}], Last position: [{traj_cols[-1]}, {traj_rows[-1]}]")
            
            style = algo_styles.get(algo_name, {'color': 'black', 'linestyle': '-', 'linewidth': 2, 
                                                'alpha': 0.7, 'marker': 'o', 'markersize': 4})
            
            # Plot trajectory line
            ax.plot(traj_cols, traj_rows, 
                   color=style['color'], linestyle=style['linestyle'], 
                   linewidth=style['linewidth'], alpha=style['alpha'],
                   label=f"{algo_name} (Episode {best_traj_data.get('episode', 'N/A')}, Reward: {best_traj_data.get('reward', 0):.2f})",
                   zorder=3)
            
            # Plot trajectory points (every few steps to avoid clutter)
            step = max(1, len(trajectory) // 20)  # Show ~20 points max
            ax.scatter(traj_cols[::step], traj_rows[::step], 
                      color=style['color'], marker=style['marker'], 
                      s=style['markersize']**2, alpha=style['alpha']*0.8, zorder=4)
            
            # Mark start point with star (only for first algorithm)
            if plotted_count == 0:
                ax.scatter([traj_cols[0]], [traj_rows[0]], 
                          color='yellow', marker='*', s=300, 
                          edgecolors='black', linewidths=2, zorder=7, label='Start Position')
            
            plotted_count += 1
            
        except Exception as e:
            print(f"Error processing trajectory for {algo_name}: {e}")
            import traceback
            traceback.print_exc()
            continue
    
    # Set axis properties
    ax.set_xlim(-0.5, COLS - 0.5)
    ax.set_ylim(-0.5, ROWS - 0.5)
    ax.set_aspect('equal')
    ax.invert_yaxis()  # Invert y-axis so row 0 is at top (like the simulation)
    ax.set_xlabel('Column', fontsize=12)
    ax.set_ylabel('Row', fontsize=12)
    ax.set_title('Best Trajectories Comparison - SARSA vs Q-Learning', fontsize=14, fontweight='bold')
    ax.legend(loc='upper left', fontsize=10, framealpha=0.9)
    ax.grid(True, alpha=0.3)
    
    if plotted_count == 0:
        print("Warning: No trajectories were plotted. Check if trajectory data exists in JSON files.")
        plt.close(fig)
        return
    
    plt.tight_layout()
    fig.savefig(os.path.join(output_path, 'Trajectories_Comparison.png'), dpi=300, bbox_inches='tight')
    plt.close(fig)
    print(f"Saved Trajectories_Comparison.png: Best Trajectories for SARSA and Q-Learning")

if __name__ == "__main__":
    print("="*70)
    print("Algorithm Comparison - KPI Analysis")
    print("="*70)
    print("\nSearching for result files in 'results' directory...")
    
    try:
        # Load all results from results directory
        dataframes = load_results_from_directory("results")
        
        if not dataframes:
            raise ValueError("No valid result files found in 'results' directory.")
        
        print(f"\nFound {len(dataframes)} algorithm(s): {', '.join(dataframes.keys())}")
        
        print("\n" + "="*70)
        print("Creating KPI comparison plots...")
        print("="*70)
        
        # Create plots
        create_kpi_plots(dataframes)
        
        print("\n" + "="*70)
        print("Creating trajectory comparison plot...")
        print("="*70)
        
        # Create trajectory plot
        create_trajectory_plot(dataframes)
        
        print("\n" + "="*70)
        print("Comparison complete!")
        print("="*70)
        print(f"\nAll KPI plots saved in: results/plots/")
        print("  - KPI1.png: Reward After Episodes")
        print("  - KPI2.png: Average Flying Time")
        print("  - KPI3.png: Average Reward")
        print("  - KPI4.png: Min Max Reward Range")
        print("  - KPI5.png: Success Rate")
        print("  - Trajectories_Comparison.png: Best Trajectories for All Algorithms")
        
    except FileNotFoundError as e:
        print(f"\nError: {e}")
        print("\nPlease run uav.py for each algorithm first to generate result files.")
        print("Expected files in 'results' directory:")
        print("  - Random_Action_results.json")
        print("  - SARSA_results.json")
        print("  - Q_Learning_results.json")
        exit(1)
    except Exception as e:
        print(f"\nError: {e}")
        import traceback
        traceback.print_exc()
        exit(1)
